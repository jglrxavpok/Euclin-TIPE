struct Node {
    data: @
    next: Node
    prev: Node
}

struct List {
    head: Node
    last: Node
    length: Int
}

var nullNode = new Node
nullNode.data = ()

func create(): List {
    var list = new List
    list
}

func length(list: List): Int {
    list.length
}

func add(target: List, element: @): Unit {
    var node = new Node
    node.data = element
    if(target.length == 0) {
        target.head = node
        target.last = node
        target.length = 1
    } else {
        var prev = target.last
        target.last = node
        node.prev = prev
        prev.next = node
        target.length = target.length+1
    }
}

func getNode(from: List, at: Int): Node {
    if(at < 0) {
        return nullNode
    }
    if(at >= length(from)) {
        return nullNode
    }
    var index = at
    var node = from.head
    while(index > 0) {
        index = index-1
        node = node.next
    }
    node
}

func get(from: List, at: Int): @ {
    getNode(from, at).data
}

func clear(target: List): Unit {
    target.length = 0
    target.head = nullNode
    target.last = nullNode
}

func forEach(target: List, action: (@) -> Unit): Unit {
    var n = length(target)
    var i = 0
    var currentNode = target.head
    while(i < n) {
        action(currentNode.data)
        currentNode = currentNode.next
        i = i+1
    }
}

/* TODO: Quand le compileur de lambdas pourra générer des fonctions "(@) -> @" (entre autres)
func map(target: List, mappingFunction: (@) -> @): List {
    var mapped = create()
    forEach(target, {
        add(mapped, mappingFunction(_))
    })
}*/